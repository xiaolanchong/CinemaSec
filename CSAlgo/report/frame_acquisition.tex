%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Процедура получения изображения}
\label{sec:frame_acquisition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
Механизм получения изображения во второй версии алгоритма реализован в виде класса \texttt{ImageAcquirer}. Поскольку входное изображение реально состоит из двух полукадров (чересстрочная развертка), иногда наблюдаются резкое отличие интенсивности чётных и нечётных строк, например, при яркой вспышке на экране. Такие кадры желательно отбросить. Кроме того, нужно отбросить слишком светлые кадры, которые появляются из-за рассинхронизации расписания когда система по ошибке включается между киносеансами. Обнаружением светлых сцен реализовано на основе т.н. алгоритма \textit{день-ночь}, раздел~\ref{sec:day-night}.

Перечень работ, выполняемых классом \texttt{ImageAcquirer}, включает ряд пунктов.
\begin{enumerate}
\itemsep = -\parsep
\item Чёрнобелое изображение поступает в \texttt{bitmap} формате. Изображение состоит из двух полукадров и имеет общий размер $720{\times}576$ пикселей. Изображение преобразуется из \texttt{bitmap} формата в чёрнобелое изображение со значениями интенсивности типа \texttt{float}. Последнее представление удобно для последующей обработки;
\item Одновременно с преобразованием происходит: (\textbf{a}) вычисление уровня шума в каждом полукадре в отдельности, по методике \cite{Akhriev04}, с использованием маски (\ref{eq:noise-mask}), (\textbf{b}) вычисление средних интенсивностей и девиаций интенсивности в каждом полукадре в отдельности, (\textbf{c}) накопление числовых характеристик необходимых для работы алгоритма \textit{день-ночь}, раздел~\ref{sec:day-night}. Таким образом измерение и преобразование происходят в одном проходе по изображению;
\item Если интегральные характеристики интенсивности в обоих полукадрах сильно разичаются, или кадр идентифицирован как светлый (день), то такой кадр должен быть отброшен, о чём сигнализирует нулевое значение при возврате из основного метода класса \texttt{ImageAcquirer::Acquire(..)};
\item Кадр признанный действительным подвергается временному сглаживанию, как это описано в разделе~\ref{sec:frame_updating}. По умолчанию мы используем метод приведённый в разделе~\ref{sec:augment-signal-noise}. Другие методы дают схожие результаты, но они, на наш взляд, должны быть дополнительно протестированы. Механизм временного сглаживания во второй версии алгоритма реализован в виде класса \texttt{FrameUpdator}.
\end{enumerate} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Алгоритм ``день-ночь''}
\label{sec:day-night}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
В перерывах между сеансами требуется останавливать подсчет зрителей когда в зале включен свет и освещенность выше, чем во время сеансов. Поэтому было решено использовать алгоритм \textit{день-ночь}, позаимствованный из системы \orwell2. Этот алгоритм применяется для определения состояния освещенности. Он возвращает ``день'', если освещенность велика, и ``ночь'' в противном случае. Алгоритм предоставляет ответ для каждого действительного кадра.
Сам алгоритм состоит в следующем. Выбирается два порога - порог интенсивности $T_i$, и порог на количество светлых пикселов $T_p$, заданный в процентах. В случае, если в данном кадре количество пикселов с интенсивностью превышающей $T_i$ составляет не менее $T_p$ процентов от общего количества всех пикселов в изображении, то алгоритм возвращает ``день'', иначе ``ночь''.

Выбор порогов осуществляется в процессе обучения, основанном на использовании гистограмм. Для этого алгоритму требуется предоставить несколько видео роликов, на которых есть как ``день'' так и ``ночь'' (причем  надо указать, на каких роликах ``день'', а на каких ``ночь''). При этом насчитываются гистограммы светлых $H_{day}$ и гистограммы темных $H_{night}$ кадров. Далее вычисляются кумулятивные функции распределения: $C_{day}[i] = \sum \nolimits _{k=i}^{255} {H_{day}[k]}$, $C_{night}[i] = \sum \nolimits _{k=i}^{255} {H_{night}[k]}$. Их значения получаются суммированием (с конца гистограмм) и помещаются в те же массивы где ранее лежали гистограммы $H_{day}$ и $H_{night}$. Далее за порог $T_i$ принимается значение интенсивности при котором разница между ``днем'' и ``ночью'' максимальна: $T_i{\,{=}\,}\arg \mathop {\max} \limits _t (C_{day}[t] - C_{night}[t])$. За порог $T_p$ принимается среднее значение количества \textit{светлых} ($I{\geqslant}T_i$) пикселов ``дня'' и ``ночи'' для найденного $T_i$, выраженное в процентах: $T_p{\,{=}\,}\myfrac 1/2 (C_{day}[T_i] + C_{night}[T_i]) \cdot 100\%$.


%\newcount\ii\ii=1
%\loop
%\ifnum\ii<255
%\advance\ii by 1
%\char\ii (\the\ii)  
%\repeat